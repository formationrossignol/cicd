node {
    // Variables adapt√©es pour macOS
    def APP_NAME = 'python-app'
    def DEPLOY_PATH = "${env.HOME}/deployed-apps/python-app"
    def LOG_FILE = "${env.HOME}/deployed-apps/logs/python-app.log"
    def BUILD_VERSION = "${BUILD_NUMBER}_${new Date().format('yyyyMMdd_HHmmss')}"
    
    try {
        stage('Checkout') {
            echo 'R√©cup√©ration du code source...'
            echo "Workspace: ${env.WORKSPACE}"
            echo "Home directory: ${env.HOME}"
            echo "Build version: ${BUILD_VERSION}"
            
            sh 'ls -la'
            
            def pyFiles = sh(script: 'find . -maxdepth 1 -name "*.py" | wc -l', returnStdout: true).trim()
            if (pyFiles == '0') {
                echo "‚ö†Ô∏è  Aucun fichier Python trouv√© √† la racine"
                echo "Cr√©ation d'une application Flask de TEST avec debug..."
                sh '''
                    cat > app.py << 'EOF'
from flask import Flask, jsonify
import os
import sys
from datetime import datetime
import logging

# Configuration des logs
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

app = Flask(__name__)

@app.route('/')
def home():
    logger.info("Route / appel√©e")
    return jsonify({
        'message': 'üéâ Application Python d√©ploy√©e avec succ√®s !',
        'version': os.environ.get('DEPLOY_VERSION', 'unknown'),
        'timestamp': datetime.now().isoformat(),
        'status': 'running',
        'port': os.environ.get('PORT', 'unknown'),
        'python_version': sys.version,
        'pid': os.getpid()
    })

@app.route('/health')
def health():
    logger.info("Health check appel√©")
    return jsonify({
        'status': 'healthy',
        'version': os.environ.get('DEPLOY_VERSION', 'unknown'),
        'port': os.environ.get('PORT', 'unknown')
    })

@app.route('/debug')
def debug():
    return jsonify({
        'environment_variables': dict(os.environ),
        'current_directory': os.getcwd(),
        'python_path': sys.path[:5]  # Premiers √©l√©ments seulement
    })

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8080))
    logger.info(f"üöÄ D√©marrage de l'application sur le port {port}")
    logger.info(f"üè† R√©pertoire de travail: {os.getcwd()}")
    logger.info(f"üêç Version Python: {sys.version}")
    
    # Force le host √† 0.0.0.0 pour √™tre accessible depuis l'ext√©rieur
    app.run(host='0.0.0.0', port=port, debug=False, threaded=True)
EOF
                    
                    cat > requirements.txt << 'EOF'
Flask==3.1.1
EOF
                    
                    echo "‚úÖ Application Flask de TEST cr√©√©e avec debug"
                '''
            }
        }
        
        stage('Setup Python Environment') {
            echo 'Configuration de l\'environnement Python...'
            sh '''
                echo "=== V√©rification Python ==="
                python3 --version
                pip3 --version
                
                echo "=== Cr√©ation environnement virtuel ==="
                if [ -d "venv" ]; then
                    rm -rf venv
                fi
                
                python3 -m venv venv
                source venv/bin/activate
                
                echo "=== Mise √† jour pip ==="
                python -m pip install --upgrade pip
                
                echo "=== Installation d√©pendances ==="
                if [ -f "requirements.txt" ]; then
                    pip install -r requirements.txt
                    echo "D√©pendances install√©es depuis requirements.txt"
                else
                    echo "Installation Flask par d√©faut"
                    pip install flask
                fi
                
                echo "=== Packages install√©s ==="
                pip list
            '''
        }
        
        stage('Pre-Deploy Diagnostic') {
            echo 'Diagnostic pr√©-d√©ploiement...'
            sh '''
                echo "=== DIAGNOSTIC SYST√àME ==="
                echo "üñ•Ô∏è  Syst√®me: $(uname -a)"
                echo "üë§ Utilisateur: $(whoami)"
                echo "üè† Home: $HOME"
                echo "üíΩ Espace disque:"
                df -h $HOME
                
                echo "=== PORTS UTILIS√âS ==="
                echo "üîç Ports en √©coute:"
                lsof -i -P | grep LISTEN | head -10
                
                echo "=== PROCESSUS PYTHON EXISTANTS ==="
                ps aux | grep python | grep -v grep || echo "Aucun processus Python"
                
                echo "=== R√âSEAU ==="
                echo "üåê Interface r√©seau:"
                ifconfig | grep -A1 "lo0\\|en0" || echo "Pas d'info r√©seau"
            '''
        }
        
        stage('Deploy') {
            echo 'D√©ploiement de l\'application...'
            
            sh '''
                echo "=== ARR√äT DE L'APPLICATION EXISTANTE ==="
                pkill -f python-app 2>/dev/null || echo "Aucun processus python-app trouv√©"
                sleep 2
                
                echo "=== PR√âPARATION R√âPERTOIRES ==="
                mkdir -p ''' + DEPLOY_PATH + '''
                mkdir -p ''' + "${env.HOME}/deployed-apps/logs" + '''
                
                # Backup avec horodatage
                if [ -d "''' + DEPLOY_PATH + '''" ] && [ "$(ls -A ''' + DEPLOY_PATH + ''' 2>/dev/null)" ]; then
                    BACKUP_DIR="''' + "${env.HOME}/deployed-apps/backups" + '''/python-app-$(date +%Y%m%d_%H%M%S)"
                    mkdir -p $(dirname $BACKUP_DIR)
                    cp -r ''' + DEPLOY_PATH + ''' $BACKUP_DIR
                    echo "‚úÖ Sauvegarde cr√©√©e: $BACKUP_DIR"
                fi
                
                rm -rf ''' + DEPLOY_PATH + '''/*
                
                echo "=== COPIE APPLICATION ==="
                cp -r dist/* ''' + DEPLOY_PATH + '''/
                
                echo "=== CONFIGURATION ENVIRONNEMENT ==="
                cd ''' + DEPLOY_PATH + '''
                
                python3 -m venv venv
                source venv/bin/activate
                pip install --upgrade pip
                
                if [ -f "requirements.txt" ]; then
                    pip install -r requirements.txt
                else
                    pip install flask
                fi
                
                chmod +x *.py
                
                echo "=== RECHERCHE PORT LIBRE AVEC DIAGNOSTIC ==="
                find_free_port() {
                    for port in 8080 8081 8082 8083 8084 8085 3000 3001 4000 4001 9000 9001; do
                        echo "üîç Test du port $port..." >&2
                        if ! lsof -i :$port > /dev/null 2>&1; then
                            echo "‚úÖ Port $port libre" >&2
                            echo $port  # Retourne SEULEMENT le num√©ro de port
                            return
                        else
                            echo "‚ùå Port $port occup√© par:" >&2
                            lsof -i :$port >&2
                        fi
                    done
                    echo "‚ö†Ô∏è  Aucun port libre trouv√©, utilisation de 8080" >&2
                    echo 8080
                }
                
                FREE_PORT=$(find_free_port)
                echo "üéØ Port s√©lectionn√©: $FREE_PORT"
                
                echo "=== CONFIGURATION APPLICATION ==="
                cat > deploy_config.py << EOF
import os
ENVIRONMENT = "dev"
PORT = $FREE_PORT
DEBUG = True  # Activ√© pour diagnostic
DEPLOY_VERSION = "''' + BUILD_VERSION + '''"
DEPLOY_PATH = "''' + DEPLOY_PATH + '''"
LOG_FILE = "''' + LOG_FILE + '''"

# Variables d'environnement
os.environ['DEPLOY_VERSION'] = DEPLOY_VERSION
os.environ['PORT'] = str(PORT)
os.environ['FLASK_ENV'] = 'development'
EOF
                
                echo "=== CR√âATION SCRIPT DE LANCEMENT AVEC DEBUG ==="
                cat > start_app.sh << EOF
#!/bin/bash
set -e  # Arr√™t si erreur

echo "üöÄ D√©marrage de l'application Python..."
echo "üìÅ R√©pertoire: \$(pwd)"
echo "üïê Heure: \$(date)"

cd ''' + DEPLOY_PATH + '''
source venv/bin/activate

# Variables d'environnement avec debug
export PYTHONPATH="''' + DEPLOY_PATH + ''':$PYTHONPATH"
export DEPLOY_VERSION="''' + BUILD_VERSION + '''"
export PORT=$FREE_PORT
export FLASK_ENV=development
export PYTHONUNBUFFERED=1  # Logs imm√©diats

echo "üîß Variables d'environnement:"
echo "PORT=\$PORT"
echo "DEPLOY_VERSION=\$DEPLOY_VERSION"
echo "PYTHONPATH=\$PYTHONPATH"

echo "üêç Version Python dans venv:"
python --version

echo "üì¶ Packages Flask:"
pip show flask

echo "üìÑ Fichiers pr√©sents:"
ls -la *.py

# Test d'import Flask
echo "üß™ Test d'import Flask:"
python -c "import flask; print(f'Flask version: {flask.__version__}')"

echo "üé¨ Lancement de l'application..."
if [ -f "app.py" ]; then
    exec python app.py
elif [ -f "main.py" ]; then
    exec python main.py
else
    echo "‚ùå Aucun fichier d'entr√©e trouv√©"
    exit 1
fi
EOF
                chmod +x start_app.sh
                
                echo "=== D√âMARRAGE APPLICATION AVEC LOGS D√âTAILL√âS ==="
                nohup ./start_app.sh > ''' + LOG_FILE + ''' 2>&1 </dev/null &
                APP_PID=$!
                
                echo "üéØ PID de d√©marrage: $APP_PID"
                
                # Attendre le d√©marrage
                echo "‚è≥ Attente du d√©marrage (10 secondes)..."
                sleep 10
                
                # V√©rifier que le processus existe toujours
                if ps -p $APP_PID > /dev/null 2>&1; then
                    echo $APP_PID > python-app.pid
                    echo "‚úÖ Processus actif (PID: $APP_PID)"
                else
                    echo "‚ùå ERREUR: Le processus a crash√© au d√©marrage"
                    echo "üìÑ Logs d'erreur:"
                    cat ''' + LOG_FILE + '''
                    exit 1
                fi
                
                # Scripts utilitaires
                cat > stop_app.sh << EOF
#!/bin/bash
if [ -f python-app.pid ]; then
    PID=\\\$(cat python-app.pid)
    if ps -p \\\$PID > /dev/null 2>&1; then
        echo "üõë Arr√™t de l'application (PID: \\\$PID)"
        kill \\\$PID
        sleep 3
        if ps -p \\\$PID > /dev/null 2>&1; then
            kill -9 \\\$PID
        fi
        rm -f python-app.pid
        echo "‚úÖ Application arr√™t√©e"
    else
        echo "‚ö†Ô∏è  Processus d√©j√† arr√™t√©"
        rm -f python-app.pid
    fi
else
    echo "‚ùå PID file non trouv√©"
fi
EOF
                chmod +x stop_app.sh
                
                cat > status_app.sh << EOF
#!/bin/bash
echo "=== STATUT APPLICATION ==="
if [ -f python-app.pid ]; then
    PID=\\\$(cat python-app.pid)
    if ps -p \\\$PID > /dev/null 2>&1; then
        echo "‚úÖ Application active (PID: \\\$PID)"
        ps -p \\\$PID -o pid,ppid,pcpu,pmem,command
    else
        echo "‚ùå Application arr√™t√©e"
    fi
else
    echo "‚ùå PID file non trouv√©"
fi

echo "üîç Processus Python:"
ps aux | grep python | grep -v grep

echo "üåê Ports en √©coute:"
lsof -i -P | grep LISTEN | grep $FREE_PORT || echo "Port $FREE_PORT pas en √©coute"

echo "üìÑ Logs r√©cents:"
tail -10 ''' + LOG_FILE + ''' 2>/dev/null || echo "Pas de logs"
EOF
                chmod +x status_app.sh
                
                echo $FREE_PORT > deployed_port.txt
                echo "üìÑ Logs: ''' + LOG_FILE + '''"
                echo "üåê URL: http://localhost:$FREE_PORT"
                echo "üìä Statut: cd ''' + DEPLOY_PATH + ''' && ./status_app.sh"
            '''
        }
        
        stage('Comprehensive Health Check') {
            echo 'V√©rification compl√®te de l\'application...'
            sh '''
                echo "=== DIAGNOSTIC COMPLET ==="
                
                cd ''' + DEPLOY_PATH + '''
                
                # V√©rifier PID
                if [ -f "python-app.pid" ]; then
                    PID=$(cat python-app.pid)
                    if ps -p $PID > /dev/null 2>&1; then
                        echo "‚úÖ Processus actif (PID: $PID)"
                        echo "üìä D√©tails du processus:"
                        ps -p $PID -o pid,ppid,pcpu,pmem,etime,command
                    else
                        echo "‚ùå Processus mort"
                        echo "üìÑ Logs complets:"
                        cat ''' + LOG_FILE + '''
                        exit 1
                    fi
                else
                    echo "‚ùå PID file manquant"
                    exit 1
                fi
                
                # V√©rifier logs
                echo "=== LOGS APPLICATION ==="
                if [ -f "''' + LOG_FILE + '''" ]; then
                    echo "üìÑ Logs r√©cents (30 derni√®res lignes):"
                    tail -30 ''' + LOG_FILE + '''
                    echo ""
                else
                    echo "‚ùå Fichier de log manquant"
                fi
                
                # V√©rifier port
                APP_PORT=$(cat deployed_port.txt 2>/dev/null || echo "8080")
                echo "=== V√âRIFICATION PORT $APP_PORT ==="
                
                if lsof -i :$APP_PORT > /dev/null 2>&1; then
                    echo "‚úÖ Port $APP_PORT en √©coute"
                    echo "üì° Processus utilisant le port:"
                    lsof -i :$APP_PORT
                else
                    echo "‚ùå Port $APP_PORT PAS en √©coute"
                    echo "üîç Tous les ports en √©coute:"
                    lsof -i -P | grep LISTEN
                    exit 1
                fi
                
                # Tests de connectivit√© progressifs
                echo "=== TESTS DE CONNECTIVIT√â ==="
                
                echo "üß™ Test 1: Ping localhost"
                ping -c 1 localhost || echo "Ping √©chou√©"
                
                echo "üß™ Test 2: Telnet sur le port"
                (echo > /dev/tcp/localhost/$APP_PORT) 2>/dev/null && echo "‚úÖ Port accessible" || echo "‚ùå Port inaccessible"
                
                echo "üß™ Test 3: Tests HTTP avec curl"
                SUCCESS=false
                for i in 1 2 3 4 5; do
                    echo "Tentative HTTP $i/5 sur http://localhost:$APP_PORT"
                    
                    if command -v curl > /dev/null; then
                        RESPONSE=$(curl -s -w "HTTP_CODE:%{http_code}" --max-time 10 http://localhost:$APP_PORT/ 2>&1)
                        HTTP_CODE=$(echo "$RESPONSE" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
                        
                        if [ "$HTTP_CODE" = "200" ]; then
                            echo "‚úÖ Application r√©pond correctement (HTTP 200)"
                            echo "üì° R√©ponse:"
                            echo "$RESPONSE" | sed 's/HTTP_CODE:[0-9]*$//'
                            SUCCESS=true
                            break
                        else
                            echo "‚ö†Ô∏è  R√©ponse HTTP: $HTTP_CODE"
                            echo "üì° Contenu: $RESPONSE"
                        fi
                    else
                        echo "‚ùå Curl non disponible"
                    fi
                    
                    if [ $i -lt 5 ]; then
                        echo "‚è≥ Attente 5 secondes..."
                        sleep 5
                    fi
                done
                
                if [ "$SUCCESS" = true ]; then
                    echo "üéâ APPLICATION FONCTIONNE PARFAITEMENT !"
                    
                    echo "üß™ Test des endpoints suppl√©mentaires:"
                    curl -s http://localhost:$APP_PORT/health && echo ""
                    curl -s http://localhost:$APP_PORT/debug | head -5 && echo ""
                    
                else
                    echo "‚ùå APPLICATION NON ACCESSIBLE VIA HTTP"
                    echo "üîç DIAGNOSTIC FINAL:"
                    echo "Processus:"
                    ps aux | grep python
                    echo "Ports:"
                    netstat -an | grep LISTEN | grep $APP_PORT || echo "Port pas trouv√© dans netstat"
                    echo "Logs complets:"
                    cat ''' + LOG_FILE + '''
                fi
                
                echo ""
                echo "=== R√âSUM√â ==="
                echo "üè† R√©pertoire: ''' + DEPLOY_PATH + '''"
                echo "üìÑ Logs: ''' + LOG_FILE + '''"
                echo "üåê Port: $APP_PORT"
                echo "üÜî PID: $(cat python-app.pid 2>/dev/null || echo 'N/A')"
                echo "üìä Statut: ./status_app.sh"
                echo "üõë Arr√™t: ./stop_app.sh"
            '''
        }
        
        // R√©cup√©rer le port pour le message final
        def deployedPort = "8080"
        try {
            deployedPort = sh(script: "cat ${DEPLOY_PATH}/deployed_port.txt 2>/dev/null || echo 8080", returnStdout: true).trim()
        } catch (Exception e) {
            deployedPort = "8080"
        }
        
        // Message de succ√®s d√©taill√©
        echo 'üéâ D√©ploiement termin√© !'
        echo """
        ===========================================
        ‚úÖ APPLICATION D√âPLOY√âE ET ACTIVE
        ===========================================
        üì± Application: ${APP_NAME}  
        üè∑Ô∏è  Version: ${BUILD_VERSION}
        üè† R√©pertoire: ${DEPLOY_PATH}
        üìÑ Logs: ${LOG_FILE}
        üåê URL: http://localhost:${deployedPort}
        ===========================================
        
        üß™ TESTS √Ä FAIRE MAINTENANT:
        
        1Ô∏è‚É£ Dans le navigateur:
           http://localhost:${deployedPort}
           http://localhost:${deployedPort}/health
           http://localhost:${deployedPort}/debug
        
        2Ô∏è‚É£ En ligne de commande:
           curl http://localhost:${deployedPort}
           curl http://localhost:${deployedPort}/health
        
        üìä COMMANDES UTILES:
        
        üîç V√©rifier statut:
        cd ${DEPLOY_PATH} && ./status_app.sh
        
        üìÑ Voir logs en temps r√©el:
        tail -f ${LOG_FILE}
        
        üõë Arr√™ter l'app:
        cd ${DEPLOY_PATH} && ./stop_app.sh
        
        üîÑ Red√©marrer l'app:
        cd ${DEPLOY_PATH} && ./start_app.sh &
        
        üîç Voir tous les ports:
        lsof -i -P | grep LISTEN
        
        ‚ö†Ô∏è  Si probl√®me persistant, v√©rifiez:
        1. Les logs: cat ${LOG_FILE}
        2. Le processus: ps aux | grep python
        3. Le port: lsof -i :${deployedPort}
        ===========================================
        """
        
    } catch (Exception e) {
        echo "‚ùå Erreur durant le d√©ploiement: ${e.getMessage()}"
        
        sh """
            echo "=== DIAGNOSTIC D'ERREUR ==="
            echo "üè† Home: ${env.HOME}"
            echo "üìÅ Workspace: \$(pwd)"
            echo "üë§ Utilisateur: \$(whoami)"
            
            echo "=== LOGS D'ERREUR ==="
            if [ -f "${LOG_FILE}" ]; then
                echo "üìÑ Logs de l'application:"
                cat ${LOG_FILE}
            else
                echo "Pas de logs d'application"
            fi
            
            echo "=== PROCESSUS ==="
            ps aux | grep python | grep -v grep || echo "Aucun processus Python"
            
            echo "=== PORTS ==="
            lsof -i -P | grep LISTEN || echo "Aucun port en √©coute"
            
            echo "=== R√âPERTOIRES ==="
            ls -la ${env.HOME}/deployed-apps/ 2>/dev/null || echo "Pas de r√©pertoire deployed-apps"
        """
        
        throw e
    } finally {
        echo 'üßπ Nettoyage du workspace...'
        sh '''
            rm -rf venv/ || true
            rm -rf __pycache__/ || true
            find . -name "*.pyc" -delete 2>/dev/null || true
        '''
    }
}
